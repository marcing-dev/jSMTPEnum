/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package pl.com.marcing.pentests.utils.jsmtpenum;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.OutputStream;
import java.io.PrintStream;
import java.net.Socket;
import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Scanner;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.apache.commons.cli.BasicParser;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.HelpFormatter;
import org.apache.commons.cli.Option;
import org.apache.commons.cli.OptionBuilder;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;

/**
 *
 * @author MarcinG
 */
public class JSMTPEnum {

    private static final String YES = "y";
    private static final String NO = "n";
    private static final Object mutex = new Object();

    private static BufferedReader br;
    private static final ArrayList<String> toTest = new ArrayList<String>();
    private static final ArrayList<String> existingUsers = new ArrayList<String>();
    private static final ArrayDeque<String> communicationQue = new ArrayDeque<String>();

    public static final String METHOD_VRFY = "VRFY";
    public static final String METHOD_RCPT = "RCPT";
    public static final String METHOD_EXPN = "EXPN";

    private static String method = METHOD_RCPT;
    private static int port = 25;
    private static int timeout = 5;
    private static String hostname;
    private static String userlist = null;
    private static String mailFrom = "user@slax.example.net";
    private static boolean debug = false;
    private static boolean verbose = false;
    private static PrintStream os;

    private static final int waitTime = 100;

    private static final Options options = new Options();

    static {
        Option help = new Option("h", "help", false, "print this message");
        options.addOption(help);
        Option optDebug = new Option("d", "debug", false, "debug mode");
        options.addOption(optDebug);
        Option optMethod = OptionBuilder.withLongOpt("method").withArgName("method").hasArg().withDescription("verify method: VRFY, EXPN or RCPT (default RCPT)").create("m");
        options.addOption(optMethod);
        Option optUserFile = OptionBuilder.withLongOpt("userlist").withArgName("filename").hasArg().withDescription("usernames list").create("U");
        options.addOption(optUserFile);
        Option optUser = OptionBuilder.withLongOpt("user").withArgName("username").hasArg().withDescription("username to check").create("u");
        options.addOption(optUser);
        Option optTarget = OptionBuilder.withLongOpt("target").withArgName("hostname").hasArg().withDescription("target hostname/ip").create("t");
        options.addOption(optTarget);
        Option optPort = OptionBuilder.withLongOpt("port").withArgName("number").hasArg().withDescription("target port (default 25)").create("p");
        options.addOption(optPort);
        Option optFrom = OptionBuilder.withLongOpt("mail-from").withArgName("email").hasArg().withDescription("MAIL FROM address for RCPT method (default: user@slax.example.net").create("f");
        options.addOption(optFrom);
        Option optTimeout = OptionBuilder.withLongOpt("timeout").withArgName("seconds").hasArg().withDescription("connection timeout in seconds (default 5)").create("w");
        options.addOption(optTimeout);
    }

    /**
     * @param args the command line arguments
     */
    public static void main(String[] args) throws InterruptedException {
        CommandLineParser parser = new BasicParser();
        CommandLine cmdLine = null;
        try {
            cmdLine = parser.parse(options, args);
        } catch (ParseException exp) {
            HelpFormatter formatter = new HelpFormatter();
            formatter.printHelp(200, "java -jar jSMTPEnum.jar", null, options, null);
            return;
        }
        if (cmdLine.hasOption("h") || (!cmdLine.hasOption("u") && !cmdLine.hasOption("U"))) {
            HelpFormatter formatter = new HelpFormatter();
            formatter.printHelp(200, "java -jar jSMTPEnum.jar", null, options, null);
            return;
        }
        if (cmdLine.hasOption("m")) {
            method = cmdLine.getOptionValue("m");
        }
        if (cmdLine.hasOption("U")) {
            userlist = cmdLine.getOptionValue("U");
        } else if (cmdLine.hasOption("u")) {
            toTest.add(cmdLine.getOptionValue("u"));
        }
        if (cmdLine.hasOption("p")) {
            port = Integer.parseInt(cmdLine.getOptionValue("p"));
        }
        if (cmdLine.hasOption("w")) {
            timeout = Integer.parseInt(cmdLine.getOptionValue("w"));
        }
        if (cmdLine.hasOption("f")) {
            mailFrom = cmdLine.getOptionValue("f");
        }
        debug = cmdLine.hasOption("d");
        hostname = cmdLine.getOptionValue("t");

        verbose |= debug;
        if (userlist != null) {
            try {
                BufferedReader br = new BufferedReader(new FileReader(userlist));
                String line;
                while ((line = br.readLine()) != null) {
                    toTest.add(line);
                }
            } catch (IOException e) {
                System.out.println("[-] Userlist file error");
            }
        }
        try {
            Socket s = new Socket(hostname, port);
            s.setSoTimeout(timeout * 1000);
            String srvResponse;
            new Pipe(s.getInputStream(), null).start();
            os = new PrintStream(s.getOutputStream());
//            InputStreamReader isr = new InputStreamReader(s.getInputStream());
//            br = new BufferedReader(isr);
            srvResponse = getServerResponse();
            if (!srvResponse.startsWith("2")) {
                System.out.println("[-] Connection failed/timed out...");
                br.close();
                os.close();
                return;
            }
            System.out.println("[+] Successfully connected to " + hostname + ":" + port);
            clearComunnicationQue();
            sendCommand("EHLO x");
            Thread.sleep(500);
            srvResponse = getServerResponse();
            if (!srvResponse.startsWith("2")) {
                System.out.println("[-] Server not respondedd for our hello msg...");
                br.close();
                os.close();
                return;
            }
            clearComunnicationQue();
            if (method.equals(METHOD_RCPT)) {
                sendCommand("MAIL FROM: " + mailFrom);
                Thread.sleep(500);
                srvResponse = getServerResponse();
                if (!srvResponse.toLowerCase().contains(" ok")) {
                    System.out.println("[-] MAIL FROM address rejected!");
                    sendCommand("QUIT");
                    br.close();
                    os.close();
                }
                for (String username : toTest) {
                    sendCommand("RCPT TO: " + username);
                    Thread.sleep(500);
                    srvResponse = getServerResponse();
                    if (srvResponse.startsWith("2")) { // positive answer
                        System.out.println("[+] User found: " + username);
                        existingUsers.add(username);
                    } else if (srvResponse.startsWith("5")) { // negative answer
                        if (verbose) {
                            System.out.println("[-] User not found: " + username);
                        }
                    } else { // uknown answer
                        if (verbose) {
                            System.out.println("[-] User not found: " + username);
                            System.out.println("[-] Uknown response: " + srvResponse);
                        }
                    }
                }

            } else if (method.equals(METHOD_VRFY) || method.equals(METHOD_EXPN)) {
                for (String username : toTest) {
                    sendCommand(method + ": " + username);
                    Thread.sleep(500);
                    srvResponse = getServerResponse();
                    if (srvResponse.startsWith("2")) { // positive answer
                        System.out.println("[+] User found: " + username);
                        existingUsers.add(username);
                    } else if (srvResponse.startsWith("5")) { // negative answer
                        if (verbose) {
                            System.out.println("[-] User not found: " + username);
                        }
                    } else { // uknown answer
                        if (verbose) {
                            System.out.println("[-] User not found: " + username);
                            System.out.println("[-] Uknown response: " + srvResponse);
                        }
                    }
                }
            } else {
                System.out.println("[-] Uknown method!");
            }
            sendCommand("QUIT");
            System.out.println(getServerResponse());
            br.close();
            os.close();
            System.out.println("[+] Found " + existingUsers.size() + " valid usernames.");
            System.out.print("[+] Print them? [Y]/n: ");
            Scanner scan = new Scanner(System.in);
            String retval = "";
            retval = scan.nextLine();
            while (retval.trim().length() > 0 && !(YES.equalsIgnoreCase(retval) || NO.equalsIgnoreCase(retval))) {
                System.out.print("[-] please type [Y]/n:");
                retval = scan.nextLine();
            }
            if (retval.trim().length() == 0 || YES.equalsIgnoreCase(retval)) {
                System.out.println("");
                System.out.println("===========================");
                System.out.println("Users in: " + hostname);
                for (String user : existingUsers) {
                    System.out.println(user);
                }
            }
        } catch (IOException ex) {
            Logger.getLogger(JSMTPEnum.class.getName()).log(Level.SEVERE, null, ex);
        }

    }

    private static void sendCommand(String command) {
        if (debug) {
            System.out.println(">> " + command);
        }
        os.print(command);
        os.print("\r\n");
        os.flush();
    }

    private static void clearComunnicationQue() {
        synchronized (mutex) {
            communicationQue.clear();
        }
    }

    private static String getServerResponse() {
        StringBuilder sb = new StringBuilder();
        int loop = 0;
        while ((loop < ((timeout * 1000) / waitTime))) {
            if (!communicationQue.isEmpty()) {
                break;
            }
            try {
                Thread.sleep(waitTime);
                loop++;
            } catch (InterruptedException ex) {
                Logger.getLogger(JSMTPEnum.class.getName()).log(Level.SEVERE, null, ex);
            }
        }
        if (communicationQue.isEmpty()) {
            return "";
        }
        try {
            Thread.sleep(500);
        } catch (InterruptedException ex) {
            Logger.getLogger(JSMTPEnum.class.getName()).log(Level.SEVERE, null, ex);
        }
        synchronized (mutex) {
            while (!communicationQue.isEmpty()) {
                sb.append(communicationQue.removeFirst().trim());
                sb.append("\n");
            }
        }
        if (debug) {
            System.out.println(sb.toString());
        }
        return sb.toString();
    }

    static class WriteEcho {

    }

    static class Pipe extends Thread {

        BufferedReader is;
        PrintStream os;

        /**
         * Construct a Pipe to read from is and write to os
         */
        Pipe(InputStream is, OutputStream os) {
            this.is = new BufferedReader(new InputStreamReader(is));
            if (os != null) {
                this.os = new PrintStream(os);
            } else {
                this.os = null;
            }
        }

        /**
         * Do the reading and writing.
         */
        @Override
        public void run() {
            String line;
            try {
                while ((line = is.readLine()) != null) {
                    if (os != null) {
                        os.print(line);
                        os.print("\r\n");
                        os.flush();
                    } else {
                        synchronized (mutex) {
                            communicationQue.addLast(line);
                        }
                    }
                }
            } catch (IOException e) {
                throw new RuntimeException(e.getMessage());
            }
        }
    }
}
